#!/bin/sh

# ================= KONFIGURATION =================
# Quell-Datastore (z.B. der interne Speicher)
SOURCE_DS="/vmfs/volumes/esxi02-datastore1"

# Ziel-Datastore (deine USB-Platte)
TARGET_DS="/vmfs/volumes/USB_TRANSFER/VM_Backups"

# Liste der VMs (Exakte Namen, keine Leerzeichen!)
VM_LIST="shs-cub01-mfc01"

# Timeout für Shutdown in Sekunden
SHUTDOWN_TIMEOUT=300
# =================================================

mkdir -p "$TARGET_DS"

for VM in $VM_LIST; do
    echo "###############################################"
    echo "Bearbeite VM: $VM"

    # -------------------------------------------------
    # 1. PRÄZISE ID-ERMITTLUNG (Der Fix für Backups)
    # -------------------------------------------------
    # Wir nutzen awk, um exakt Spalte 2 (Name) zu prüfen.
    # Wenn Name == VM, dann drucke Spalte 1 (ID).
    VM_ID=$(vim-cmd vmsvc/getallvms | awk -v target="$VM" '$2 == target {print $1}')

    # Falls wir immer noch mehrere IDs bekommen (sehr unwahrscheinlich) oder gar keine:
    # Wir nehmen nur die erste Zeile.
    VM_ID=$(echo "$VM_ID" | head -n 1)

    if [ -z "$VM_ID" ] || [ "$VM_ID" = "Vmid" ]; then
        echo "FEHLER: Konnte VM-ID für '$VM' nicht finden (oder Name ist mehrdeutig)."
        continue
    fi
    echo "-> VM-ID gefunden: $VM_ID"

    # -------------------------------------------------
    # 2. AUTO-SHUTDOWN
    # -------------------------------------------------
    POWER_STATE=$(vim-cmd vmsvc/power.getstate "$VM_ID" | grep "Powered on")
    WAS_RUNNING=0

    if [ -n "$POWER_STATE" ]; then
        echo "-> VM läuft. Starte Shutdown..."
        WAS_RUNNING=1
        vim-cmd vmsvc/power.shutdown "$VM_ID"
        
        TIMER=0
        while vim-cmd vmsvc/power.getstate "$VM_ID" | grep -q "Powered on"; do
            sleep 5
            TIMER=$((TIMER+5))
            echo "   ...warte auf Shutdown ($TIMER s)"
            if [ $TIMER -ge $SHUTDOWN_TIMEOUT ]; then
                echo "-> WARNUNG: Timeout! Erzwinge Power-Off."
                vim-cmd vmsvc/power.off "$VM_ID"
                break
            fi
        done
    else
        echo "-> VM ist bereits aus."
    fi

    # -------------------------------------------------
    # 3. SMART EXPORT (Snapshots konsolidieren)
    # -------------------------------------------------
    SRC_DIR="$SOURCE_DS/$VM"
    DST_DIR="$TARGET_DS/$VM"

    # Zielordner bereinigen (Wichtig!)
    if [ -d "$DST_DIR" ]; then
        echo "-> Lösche alten Zielordner..."
        rm -rf "$DST_DIR"
    fi
    mkdir -p "$DST_DIR"

    echo "-> Kopiere Config (.vmx, .nvram)..."
    cp "$SRC_DIR/"*.nvram "$DST_DIR/" 2>/dev/null
    cp "$SRC_DIR/"*.vmsd "$DST_DIR/" 2>/dev/null
    
    # VMX kopieren zur Bearbeitung
    cp "$SRC_DIR/$VM.vmx" "$DST_DIR/$VM.vmx"

    echo "-> Analysiere aktive Festplatten (Snapshot-Kette)..."
    
    # Wir lesen aus der VMX, welche vmdk aktuell eingebunden ist (das ist oft der Snapshot 0000x)
    grep ".fileName" "$SRC_DIR/$VM.vmx" | grep ".vmdk" | while read -r line ; do
        
        CURRENT_DISK=$(echo "$line" | awk -F'"' '{print $2}')
        
        # Sauberer Zielname ohne Snapshot-Nummern
        BASENAME=$(basename "$CURRENT_DISK" .vmdk)
        # Entferne Snapshot-Nummern aus dem Zielnamen
        CLEAN_NAME=$(echo "$BASENAME" | sed 's/-[0-9]\{6\}//')
        TARGET_DISK_NAME="${CLEAN_NAME}.vmdk"

        echo "   -> Quelle: $CURRENT_DISK"
        echo "   -> Ziel:   $TARGET_DISK_NAME (Thin & Consolidated)"

        # Der Zaubertrick: vmkfstools liest die Snapshot-Kette und schreibt EINE saubere Datei
        # Wir ignorieren Digest-Fehler, da wir nur die Daten wollen
        vmkfstools -i "$SRC_DIR/$CURRENT_DISK" -d thin "$DST_DIR/$TARGET_DISK_NAME"

        if [ $? -eq 0 ]; then
            # VMX auf dem Stick anpassen: Alter Snapshot-Name -> Neuer sauberer Name
            sed -i "s|$CURRENT_DISK|$TARGET_DISK_NAME|g" "$DST_DIR/$VM.vmx"
        else
            echo "   [FEHLER] Klonen fehlgeschlagen!"
        fi
    done

    # VMX bereinigen (Swap Pfade und UUIDs entfernen für sauberen Import)
    sed -i '/sched.swap.derivedName/d' "$DST_DIR/$VM.vmx"
    sed -i '/uuid.location/d' "$DST_DIR/$VM.vmx"

    # -------------------------------------------------
    # 4. RESTORE STATE (Wieder hochfahren)
    # -------------------------------------------------
    if [ $WAS_RUNNING -eq 1 ]; then
        echo "-> Starte VM wieder..."
        vim-cmd vmsvc/power.on "$VM_ID"
    fi

    echo "Fertig mit $VM"
done

echo "###############################################"
echo "Alle Aufgaben abgeschlossen."